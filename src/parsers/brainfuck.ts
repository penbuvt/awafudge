import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */
export class BrainfuckParser extends JisonParser implements JisonParserApi {
    $?: any;
    symbols_: SymbolsType = {"error":2,"program":3,"operations":4,"EOF":5,"operation":6,"LEFTSHIFTS":7,"RIGHTSHIFTS":8,"INCREMENTS":9,"DECREMENTS":10,"INPUT":11,"OUTPUT":12,"loop":13,"[":14,"]":15,"LEFTSHIFT":16,"<":17,"RIGHTSHIFT":18,">":19,"INCREMENT":20,"+":21,"DECREMENT":22,"-":23,",":24,".":25,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF",7:"LEFTSHIFTS",8:"RIGHTSHIFTS",9:"INCREMENTS",10:"DECREMENTS",14:"[",15:"]",17:"<",19:">",21:"+",23:"-",24:",",25:"."};
    productions_: ProductionsType = [0,[3,2],[4,0],[4,2],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[13,3],[16,1],[18,1],[20,1],[22,1],[11,1],[12,1]];
    table: Array<StateType>;
    defaultActions: {[key:number]: any} = {3:[2,1]};

    constructor (yy = {}, lexer = new BrainfuckLexer(yy)) {
      super(yy, lexer);

      // shorten static method to just `o` for terse STATE_TABLE
      const $V0=[2,2],$V1=[1,5],$V2=[1,6],$V3=[1,7],$V4=[1,8],$V5=[1,14],$V6=[1,12],$V7=[1,13],$V8=[5,7,8,9,10,14,15,24,25];
      const o = JisonParser.expandParseTable;
      this.table = [o([5,7,8,9,10,14,24,25],$V0,{3:1,4:2}),{1:[3]},{5:[1,3],6:4,7:$V1,8:$V2,9:$V3,10:$V4,11:9,12:10,13:11,14:$V5,24:$V6,25:$V7},{1:[2,1]},o($V8,[2,3]),o($V8,[2,4]),o($V8,[2,5]),o($V8,[2,6]),o($V8,[2,7]),o($V8,[2,8]),o($V8,[2,9]),o($V8,[2,10]),o($V8,[2,16]),o($V8,[2,17]),o([7,8,9,10,14,15,24,25],$V0,{4:15}),{6:4,7:$V1,8:$V2,9:$V3,10:$V4,11:9,12:10,13:11,14:$V5,15:[1,16],24:$V6,25:$V7},o($V8,[2,11])];
    }

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
return $$[$0-1];
break;
case 2:
this.$ = [];
break;
case 3:
this.$ = ($$[$0-1].push($$[$0]), $$[$0-1]);
break;
case 4:
this.$ = { type: 'LEFT_SHIFT', count: yyleng };
break;
case 5:
this.$ = { type: 'RIGHT_SHIFT', count: yyleng };
break;
case 6:
this.$ = { type: 'INCREMENT', count: yyleng };
break;
case 7:
this.$ = { type: 'DECREMENT', count: yyleng };
break;
case 8:
this.$ = { type: 'READ' };
break;
case 9:
this.$ = { type: 'WRITE' };
break;
case 11:
this.$ = { type: 'LOOP', content: $$[$0-1] };
break;
        }
    }
}


/* generated by @ts-jison/lexer-generator 0.4.1-alpha.2 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';

export class BrainfuckLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"Brainfuck"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [
        /^(?:[^-+<>\[\],.]+)/,
        /^(?:-+)/,
        /^(?:\++)/,
        /^(?:<+)/,
        /^(?:>+)/,
        /^(?:\[)/,
        /^(?:\])/,
        /^(?:\.)/,
        /^(?:,)/,
        /^(?:$)/
    ];
    conditions: any = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:/* ignore all other characters */
      break;
    case 1:return 10;
      break;
    case 2:return 9;
      break;
    case 3:return 7;
      break;
    case 4:return 8;
      break;
    case 5:return 14;
      break;
    case 6:return 15;
      break;
    case 7:return 25;
      break;
    case 8:return 24;
      break;
    case 9:return 5;
      break;
        }
    }
}


